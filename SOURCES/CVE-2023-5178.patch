From 18173926d32b1ddf767f5c856c1198651b837c85 Mon Sep 17 00:00:00 2001
From: Ryan Sullivan <rysulliv@redhat.com>
Date: Thu, 30 Nov 2023 13:40:00 -0500
Subject: [KPATCH CVE-2023-5178] kpatch fixes for CVE-2023-5178

Kernels:
5.14.0-362.8.1.el9_3


Kpatch-MR: https://gitlab.com/redhat/prdsc/rhel/src/kpatch/rhel-9/-/merge_requests/74
Approved-by: Yannick Cote (@ycote1)
Approved-by: Joe Lawrence (@joe.lawrence)
Changes since last build:
[x86_64]:
af_unix.o: changed function: unix_stream_sendpage
ip_set_hash_netportnet.o: changed function: hash_netportnet4_uadt
ip_set_hash_netportnet.o: changed function: hash_netportnet6_uadt
sch_hfsc.o: changed function: hfsc_change_class
tcp.o: changed function: nvmet_tcp_handle_icreq
tcp.o: changed function: nvmet_tcp_io_work
tcp.o: changed function: nvmet_tcp_try_recv.constprop.0
tun.o: changed function: tun_napi_alloc_frags

[ppc64le]:
af_unix.o: changed function: unix_stream_sendpage
ip_set_hash_netportnet.o: changed function: hash_netportnet4_resize
ip_set_hash_netportnet.o: changed function: hash_netportnet4_uadt
ip_set_hash_netportnet.o: changed function: hash_netportnet4_uref
ip_set_hash_netportnet.o: changed function: hash_netportnet6_resize
ip_set_hash_netportnet.o: changed function: hash_netportnet6_uadt
ip_set_hash_netportnet.o: changed function: hash_netportnet6_uref
sch_hfsc.o: changed function: hfsc_change_class
tcp.o: changed function: nvmet_tcp_handle_icreq
tcp.o: changed function: nvmet_tcp_io_work
tcp.o: changed function: nvmet_tcp_try_recv.constprop.0
tun.o: changed function: tun_napi_alloc_frags

---------------------------

Modifications: none

commit 91a5bf5b0017063e4fa1859a8c917a929ca5fba1
Author: John Meneghini <jmeneghi@redhat.com>
Date:   Fri Oct 13 09:08:15 2023 -0400

    nvmet-tcp: Fix a possible UAF in queue intialization setup

    JIRA: https://issues.redhat.com/browse/RHEL-11487
    JIRA: https://issues.redhat.com/browse/RHEL-11491
    CVE: CVE-2023-5178
    Y-Commit: 33d046c7e088221af5d96d160a0dc42bbec098df

    O-JIRA: https://issues.redhat.com/browse/RHEL-11488
    O-CVE: CVE-2023-5178
    O-JIRA: https://issues.redhat.com/browse/RHEL-11492
    O-CVE: CVE-2023-5178

    Upstream Status: git://git.infradead.org/nvme.git

    From Alon:
    "Due to a logical bug in the NVMe-oF/TCP subsystem in the Linux kernel,
    a malicious user can cause a UAF and a double free, which may lead to
    RCE (may also lead to an LPE in case the attacker already has local
    privileges)."

    Hence, when a queue initialization fails after the ahash requests are
    allocated, it is guaranteed that the queue removal async work will be
    called, hence leave the deallocation to the queue removal.

    Also, be extra careful not to continue processing the socket, so set
    queue rcv_state to NVMET_TCP_RECV_ERR upon a socket error.

    Cc: stable@vger.kernel.org
    Reported-by: Alon Zahavi <zahavi.alon@gmail.com>
    Tested-by: Alon Zahavi <zahavi.alon@gmail.com>
    Signed-off-by: Sagi Grimberg <sagi@grimberg.me>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Chaitanya Kulkarni <kch@nvidia.com>
    Signed-off-by: Keith Busch <kbusch@kernel.org>
    (cherry picked from commit d920abd1e7c4884f9ecd0749d1921b7ab19ddfbd)
    Signed-off-by: John Meneghini <jmeneghi@redhat.com>
    Signed-off-by: Jan Stancek <jstancek@redhat.com>

Signed-off-by: Ryan Sullivan <rysulliv@redhat.com>
---
 drivers/nvme/target/tcp.c | 7 ++-----
 1 file changed, 2 insertions(+), 5 deletions(-)

diff --git a/drivers/nvme/target/tcp.c b/drivers/nvme/target/tcp.c
index 8ef9e42b8efc..6c98bdfeeac7 100644
--- a/drivers/nvme/target/tcp.c
+++ b/drivers/nvme/target/tcp.c
@@ -345,6 +345,7 @@ static void nvmet_tcp_fatal_error(struct nvmet_tcp_queue *queue)
 
 static void nvmet_tcp_socket_error(struct nvmet_tcp_queue *queue, int status)
 {
+	queue->rcv_state = NVMET_TCP_RECV_ERR;
 	if (status == -EPIPE || status == -ECONNRESET)
 		kernel_sock_shutdown(queue->sock, SHUT_RDWR);
 	else
@@ -871,15 +872,11 @@ static int nvmet_tcp_handle_icreq(struct nvmet_tcp_queue *queue)
 	iov.iov_len = sizeof(*icresp);
 	ret = kernel_sendmsg(queue->sock, &msg, &iov, 1, iov.iov_len);
 	if (ret < 0)
-		goto free_crypto;
+		return ret; /* queue removal will cleanup */
 
 	queue->state = NVMET_TCP_Q_LIVE;
 	nvmet_prepare_receive_pdu(queue);
 	return 0;
-free_crypto:
-	if (queue->hdr_digest || queue->data_digest)
-		nvmet_tcp_free_crypto(queue);
-	return ret;
 }
 
 static void nvmet_tcp_handle_req_failure(struct nvmet_tcp_queue *queue,
-- 
2.43.0


